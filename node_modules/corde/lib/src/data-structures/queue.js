"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.Queue = exports.createHash = void 0;

const tslib_1 = require("tslib");

const crypto_1 = (0, tslib_1.__importDefault)(require("crypto"));

function createHash() {
  const current_date = new Date().valueOf().toString();
  const random = Math.random().toString();
  return crypto_1.default
    .createHash("sha1")
    .update(current_date + random)
    .digest("hex");
}

exports.createHash = createHash;

class Queue {
  constructor() {
    this._funcs = new Map();
    this._defaultParameters = [];
  }

  get defaultParameters() {
    return this._defaultParameters;
  }

  get size() {
    return this._funcs.size;
  }

  get hasFunctions() {
    return this._funcs.size > 0;
  }

  get hasDefaultParameters() {
    return this._defaultParameters.length > 0;
  }

  get defaultParametersSize() {
    return this._defaultParameters.length;
  }

  enqueue(fn) {
    if (!fn) {
      throw new Error("Can not add an null | undefined value");
    }

    if (typeof fn !== "function") {
      throw new Error("Can not add a type that is not a function");
    }

    const hash = createHash();

    this._funcs.set(hash, fn);

    return hash;
  }

  dequeue(guid) {
    if (!guid) {
      return false;
    }

    return this._funcs.delete(guid);
  }

  async executeAsync(...params) {
    if (!this.hasFunctions) {
      return [];
    }

    const parameters = [...params, ...this._defaultParameters];
    const returnList = [];

    for (const [, fn] of this._funcs) {
      this.checkFunctionArgumentsSize(fn, parameters);
      const value = await fn(...parameters);

      if (value) {
        returnList.push(value);
      }
    }

    this.clear();
    return returnList;
  }

  executeSync(...params) {
    if (!this.hasFunctions) {
      return [];
    }

    const parameters = [...params, ...this._defaultParameters];
    const returnList = [];

    for (const [, fn] of this._funcs) {
      this.checkFunctionArgumentsSize(fn, parameters);
      const value = fn(...parameters);

      if (value) {
        returnList.push(value);
      }
    }

    this.clear();
    return returnList;
  }

  tryExecuteSync(catchAction, ...params) {
    if (!this.hasFunctions) {
      return [];
    }

    const parameters = [...params, ...this._defaultParameters];
    const returnValues = [];

    for (const [, fn] of this._funcs) {
      this.checkFunctionArgumentsSize(fn, parameters);

      try {
        const value = fn(...parameters);

        if (value) {
          returnValues.push(value);
        }
      } catch (error) {
        if (catchAction) {
          catchAction(error);
        }
      }
    }

    this.clear();
    return returnValues;
  }

  async tryExecuteAsync(catchAction, ...params) {
    if (!this.hasFunctions) {
      return [];
    }

    const parameters = [...params, ...this._defaultParameters];
    const returnValues = [];

    for (const [, fn] of this._funcs) {
      this.checkFunctionArgumentsSize(fn, parameters);

      try {
        const value = await fn(...parameters);

        if (value) {
          returnValues.push(value);
        }
      } catch (error) {
        if (catchAction) {
          catchAction(error);
        }
      }
    }

    this.clear();
    return returnValues;
  }

  executeWithCatchCollectSync(...params) {
    if (!this.hasFunctions) {
      return [];
    }

    const parameters = [...params, ...this._defaultParameters];
    const errors = [];

    for (const [, fn] of this._funcs) {
      this.checkFunctionArgumentsSize(fn, parameters);

      try {
        fn(...parameters);
      } catch (error) {
        errors.push(error);
      }
    }

    this.clear();
    return errors;
  }

  async executeWithCatchCollectAsync(...params) {
    if (!this.hasFunctions) {
      return [];
    }

    const parameters = [...params, ...this._defaultParameters];
    const errors = [];

    for (const [, fn] of this._funcs) {
      this.checkFunctionArgumentsSize(fn, parameters);

      try {
        await fn(...parameters);
      } catch (error) {
        errors.push(error);
      }
    }

    this.clear();
    return errors;
  }

  addDefaultParameters(...parameter) {
    if (parameter) {
      this._defaultParameters.push(...parameter);
    }
  }

  clearDefaultParameters() {
    this._defaultParameters = [];
  }

  removeFromDefaultParameter(...parameters) {
    if (!this.hasDefaultParameters) {
      return;
    }

    for (const parameter of parameters) {
      const index = this._defaultParameters.indexOf(parameter);

      if (index > -1) {
        this._defaultParameters.splice(index, 1);
      }
    }
  }

  clear() {
    return this._funcs.clear();
  }

  isDefaultArgumentsValid() {
    if (!this.hasFunctions) {
      return true;
    }

    try {
      this.checkFunctionArgumentsSize(this.first(), this.defaultParameters);
      return true;
    } catch (error) {
      return false;
    }
  }

  first() {
    if (!this.hasFunctions) {
      return null;
    }

    const keyValue = this._funcs.entries().next().value;

    return keyValue[1];
  }

  checkFunctionArgumentsSize(fn, argsToPass) {
    if (!fn) {
      return;
    }

    if (fn.length !== argsToPass.length) {
      throw new Error(
        `Could not pass more arguments ${argsToPass.length} than what the function ${fn.name} supports ${fn.length}`,
      );
    }
  }
}

exports.Queue = Queue;
