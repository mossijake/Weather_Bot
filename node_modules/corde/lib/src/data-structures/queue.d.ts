import { GenericFunction, ParametersAsOptional } from "../types";
export declare function createHash(): string;
/**
 * Structure to handle a collection of functions and execute then.
 * This structure does not remove its values after its executions.
 */
export declare class Queue<T extends GenericFunction> {
  private readonly _funcs;
  private _defaultParameters;
  /**
   * Gets default parameters added.
   */
  get defaultParameters(): Parameters<T>[];
  get size(): number;
  get hasFunctions(): boolean;
  get hasDefaultParameters(): boolean;
  get defaultParametersSize(): number;
  constructor();
  /**
   * Add a function to queue.
   *
   * @param fn Functions to be queued
   * @throws Error if `fn` is null, undefined, or if the value
   * is not a function.
   *
   * @returns A **hash** for the function
   */
  enqueue(fn: T): string;
  /**
   * Removes a function from the queue
   * @param fn Function to be removed from the queue.
   */
  dequeue(guid: string): boolean;
  /**
   * Execute functions with parameters.
   * @param params Parameters to be injected on function in queue.
   */
  executeAsync<K extends ParametersAsOptional<T>, U extends ReturnType<T>>(
    ...params: K
  ): Promise<U[]>;
  /**
   * Execute functions with parameters.
   * @param params Parameters to be injected on function in queue.
   */
  executeSync<K extends ParametersAsOptional<T>, U extends ReturnType<T>>(...params: K): U[];
  /**
   * Execute function with exception treatment.
   * So if any function throw a error, it will be handled by an catch function
   * provided in parameters.
   * @param catchAction Function to handle errors.
   * @param params Parameters to the functions.
   */
  tryExecuteSync<K extends ParametersAsOptional<T>, U extends ReturnType<T>>(
    catchAction?: (error: any) => void,
    ...params: K
  ): U[];
  /**
   * Execute function with exception treatment.
   * So if any function throw a error, it will be handled by an catch function
   * provided in parameters.
   * @param catchAction Function to handle errors.
   * @param params Parameters to the functions.
   */
  tryExecuteAsync<K extends ParametersAsOptional<T>, U extends ReturnType<T>>(
    catchAction?: GenericFunction,
    ...params: K
  ): Promise<U[]>;
  /**
   * Function like *tryExecute()* but return all exceptions if they
   * occur.
   * @param params Parameters to the functions.
   */
  executeWithCatchCollectSync<K extends ParametersAsOptional<T>>(...params: K): any[];
  /**
   * Function like *tryExecute()* but return all exceptions if they
   * occur.
   * @param params Parameters to the functions.
   */
  executeWithCatchCollectAsync<K extends ParametersAsOptional<T>>(...params: K): Promise<any[]>;
  /**
   * Add parameters to be injected on queued functions
   * @param parameter Parameter value
   */
  addDefaultParameters<K extends Parameters<T>>(...parameter: K): void;
  /**
   * Removes all default parameters from the queue
   */
  clearDefaultParameters(): void;
  /**
   * Removes a specific default parameter
   * @param parameters Parameter to remove
   *
   */
  removeFromDefaultParameter<K extends Parameters<T>>(...parameters: K): void;
  /**
   * Removes all elements from the queue
   * @returns The own queue.
   */
  clear(): void;
  /**
   * Check if default arguments correctly fill all expected arguments
   * for functions in the queue.
   *
   * @returns `true` if arguments are ok or there is no function added
   * and `false` if it's going to pass more or fewer arguments than necessary.
   *
   * @example
   *
   * const queue = new Queue<(sum: number) => number>();
   * queue.addDefaultParameters(1);
   * queue.addDefaultParameters(3);
   * queue.isDefaultArgumentsValid(); // false - expect 1 arg, received 2
   *
   * const queue2 = new Queue<(sum: number) => number>();
   * queue2.isDefaultArgumentsValid(); // false - expect 1 arg, received 0
   *
   * const queue3 = new Queue<(sum: number) => number>();
   * queue3.addDefaultParameters(1);
   * queue3.isDefaultArgumentsValid(1); // true - expect 1 arg, received 1
   */
  isDefaultArgumentsValid(): boolean;
  /**
   * Gets the first functions queued or null if there no functions queued.
   */
  first(): T | null;
  private checkFunctionArgumentsSize;
}
