"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.BotAPI = void 0;

const errors_1 = require("../errors");

const messageMapper_1 = require("../mapper/messageMapper");

const utils_1 = require("../utils");

class BotAPI {
  constructor(bot) {
    this._bot = bot;
  }

  get voiceState() {
    return this._bot.voiceConnection;
  }

  get client() {
    return this._bot.client;
  }

  get channel() {
    return this.getChannel();
  }

  get channels() {
    this._throwErrorIfNotLogged();

    return this._bot.client.channels.cache.array();
  }

  get guild() {
    return this.getGuild();
  }

  get guildMembers() {
    this._throwErrorIfNotLogged();

    return this.guild.members.cache.array();
  }

  get guilds() {
    this._throwErrorIfNotLogged();

    return this._bot.client.guilds.cache.array();
  }

  get roles() {
    this._throwErrorIfNotLogged();

    return this.getGuild().roles.cache.array();
  }

  get isLoggedIn() {
    return this._bot.isLoggedIn();
  }

  isMessageAuthor(message) {
    return message.author.id === this._bot.id;
  }

  joinVoiceChannel(channelId) {
    this._throwErrorIfNotLogged(
      "Can not join a voice channel while corde bot is not connected yet",
    );

    return this._bot.joinVoiceChannel(channelId);
  }

  leaveVoiceChannel() {
    this._throwErrorIfNotLogged("Can not leave a voice channel as corde bot is not connected yet");

    this._bot.leaveVoiceChannel();
  }

  getOnlyTextChannels() {
    this._throwErrorIfNotLogged();

    return this.channels.filter((c) => c.isText());
  }

  isInVoiceChannel() {
    return this._bot.isInVoiceChannel();
  }

  fetchChannel(id) {
    this._throwErrorIfNotLogged();

    return this._bot.fetchChannel(id);
  }

  fetchGuild(id) {
    this._throwErrorIfNotLogged();

    return this._bot.fetchGuild(id);
  }

  async fetchRole(roleId, guildId, fetchGuild = false) {
    this._throwErrorIfNotLogged("Could not create the guild while corde bot isn't connected yet");

    if (guildId) {
      const guild = await this._getOrFetchGuild(guildId, fetchGuild);

      if (!guild) {
        return undefined;
      }

      return this._fetchRole(roleId, this.guild);
    }

    return this._fetchRole(roleId, this.guild);
  }

  _getOrFetchGuild(guildId, fetchGuild = false) {
    if (fetchGuild) {
      return this._bot.client.guilds.fetch(guildId);
    } else {
      return this._bot.client.guilds.cache.get(guildId);
    }
  }

  getChannel(identifier) {
    this._throwErrorIfNotLogged("Corde is not connected yet to fetch any data");

    if (!identifier) {
      return this._bot.channel;
    }

    if (typeof identifier === "string") {
      return this._bot.client.channels.cache.find((c) => c.id === identifier);
    }

    return this._bot.client.channels.cache.find((c) => {
      if (c.id === identifier.id) {
        return true;
      }

      if (c.isText()) {
        return c.name === identifier.name;
      }

      return false;
    });
  }

  getGuild(identifier) {
    this._throwErrorIfNotLogged("Can not get any guild while corde bot is not connected yet");

    if (!identifier) {
      return this._bot.guild;
    }

    if (typeof identifier === "string") {
      return this._bot.client.guilds.cache.find((c) => c.id === identifier);
    }

    return this._bot.client.guilds.cache.find(
      (c) => c.id === identifier.id || c.name === identifier.name,
    );
  }

  send(message) {
    if (!message) {
      throw new Error("Can not send a empty message");
    }

    this._throwErrorIfNotLogged(
      "Can not send a directly message to channel because the client is not connected yet",
    );

    if ((0, utils_1.isPrimitiveValue)(message)) {
      return this._bot.sendMessage(message);
    }

    const embed = messageMapper_1.mapper.embedInterfaceToMessageEmbed(message);
    return this._bot.sendMessage(embed);
  }

  createRole(data) {
    this._throwErrorIfNotLogged("Bot is not connected yet. Can not create a role");

    if (typeof data === "string") {
      return this._bot.roleManager.create({
        data: {
          name: data,
        },
      });
    }

    return this._bot.roleManager.create({
      data,
    });
  }

  _throwErrorIfInvalidName(name, errorMessage) {
    if (!name || typeof name !== "string" || !name.trim()) {
      throw new Error(errorMessage);
    }
  }

  createGuild(options) {
    this._throwErrorIfNotLogged("Could not create the guild while corde bot isn't connected yet");

    const errorMessage = "Could not create a guild with an invalid name";

    if (typeof options === "string") {
      this._throwErrorIfInvalidName(options, errorMessage);

      return this._bot.client.guilds.create(options);
    }

    this._throwErrorIfInvalidName(options.name, errorMessage);

    return this._bot.client.guilds.create(options.name, options);
  }

  createChannel(options) {
    this._throwErrorIfNotLogged("Could not create the channel while corde bot isn't connected yet");

    if (typeof options === "string") {
      return this.guild.channels.create(options);
    }

    return this.guild.channels.create(options.name, options);
  }

  createVoiceChannel(options) {
    return this._createChannel(options, "voice");
  }

  createTextChannel(options) {
    return this._createChannel(options, "text");
  }

  createCategoryChannel(options) {
    return this._createChannel(options, "category");
  }

  getRole(data) {
    this._throwErrorIfNotLogged("Bot is not connected yet. No role can be searched");

    return this._getRole(data);
  }

  async _fetchRole(roleId, guild) {
    const role = await guild.roles.fetch(roleId, true);

    if (role) {
      return role;
    }

    return undefined;
  }

  _getRole(data) {
    if (typeof data === "string") {
      return this._bot.getRoles().find((r) => r.id === data);
    }

    return this._bot.getRoles().find((r) => r.id === data.id || r.name === data.name);
  }

  _createChannel(options, type) {
    this._throwErrorIfNotLogged("Could not create the channel while corde bot isn't connected yet");

    if (typeof options === "string") {
      return this.guild.channels.create(options, {
        type,
      });
    }

    return this.guild.channels.create(options.name, { ...options, type });
  }

  _throwErrorIfNotLogged(message = "Corde is not connected yet to fetch any data") {
    if (!this.isLoggedIn) {
      throw new errors_1.CordeClientError(message);
    }
  }
}

exports.BotAPI = BotAPI;
