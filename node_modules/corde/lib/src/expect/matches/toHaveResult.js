"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.IToHaveResult = void 0;

const tslib_1 = require("tslib");

const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));

const consts_1 = require("../../consts");

const expectTest_1 = require("./expectTest");

class IToHaveResult extends expectTest_1.ExpectTest {
  constructor(params) {
    super({ ...params, testName: "todoInCascade" });
  }

  async action(...assertions) {
    if (!assertions || assertions.length === 0) {
      return this.createReport("no assertions were provided to test");
    }

    await this.sendCommandMessage(true);
    let tests = [];

    try {
      tests = await Promise.all(assertions.map((assertion) => assertion()));
    } catch (error) {
      if (this.isNot) {
        return this.createPassTest();
      }

      if (error instanceof Error) {
        return this.createFailedTest(error.message);
      }

      return this.createFailedTest(error);
    }

    if (this.isNot && !tests.some((test) => test.pass)) {
      return this.createPassTest();
    }

    if (!this.isNot && !tests.some((test) => !test.pass)) {
      return this.createPassTest();
    }

    if (this.isNot && tests.some((test) => test.pass)) {
      return this.createReport(
        "expected: all tests to fail\n",
        "received: some tests has passed\n",
        ...this.filterTestsNames(tests, (test) => test.pass),
      );
    }

    return this.createReport(
      "expected: all tests to pass\n",
      "received: some tests has failed\n",
      ...this.formatFailedTestsMessage(tests),
    );
  }

  formatFailedTestsMessage(tests) {
    return tests
      .filter((test) => !test.pass)
      .map((test, index) => {
        let partial = "";

        if (index > 0) {
          partial += "\n";
        }

        partial += `${consts_1.EXPECT_RECEIVED_TAB_SPACE}${chalk_1.default.red(
          `● ${test.testName}. Response: \n` +
            chalk_1.default.red(this.formatReportMessage(test.message)),
        )}`;
        return partial;
      });
  }

  formatReportMessage(message) {
    if (!message) {
      return "";
    }

    const lineBreakRegex = new RegExp(/\n/g);
    return message.replace("\n", "").replace(lineBreakRegex, "\n    ");
  }

  filterTestsNames(tests, filterFn) {
    return tests
      .filter(filterFn)
      .map(
        (test) =>
          `${consts_1.EXPECT_RECEIVED_TAB_SPACE} ${chalk_1.default.red(`● ${test.testName}\n`)}`,
      );
  }
}

exports.IToHaveResult = IToHaveResult;
