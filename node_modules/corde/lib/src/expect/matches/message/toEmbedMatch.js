"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.ToEmbedMatch = void 0;

const utils_1 = require("../../../utils");

const messageExpectTest_1 = require("./messageExpectTest");

class ToEmbedMatch extends messageExpectTest_1.MessageExpectTest {
  constructor(params) {
    super({ ...params, testName: "toEmbedMatch" });
  }

  async action(embed) {
    if ((0, utils_1.typeOf)(embed) !== "object") {
      return this.createFailedTest(
        "expected: parameter to be an object of type IMesageEmbed \n",
        `received: ${(0, utils_1.typeOf)(embed)}`,
      );
    }

    try {
      await this.sendCommandMessage();
    } catch (error) {
      return this.createFailedTest(error.message);
    }

    let returnedMessage;

    try {
      returnedMessage = await this.cordeBot.events.onceMessage(
        this.cordeBot.testBotId,
        this.channelId,
        this.timeout,
      );
    } catch {
      if (this.isNot) {
        return this.createPassTest();
      }

      return this.createReport(
        "expected: testing bot to send a message\n",
        "received: no message was sent",
      );
    }

    if (!returnedMessage.embeds || !returnedMessage.embeds[0]) {
      return this.createFailedTest("returned message has no embed message");
    }

    const formatedReturnedEmbed = this.messageEmbedToMessageEmbedInterface(
      returnedMessage.embeds[0],
    );
    this.hasPassed = (0, utils_1.isPartialOf)(embed, formatedReturnedEmbed);
    this.invertHasPassedIfIsNot();

    if (this.hasPassed) {
      return this.createPassTest();
    }

    if (this.isNot) {
      return this.createReport(
        "expected: embed message from bot do not match with expectation\n",
        "received: both returned and expectation embed messages matches",
      );
    }

    const partialReturned = (0, utils_1.pick)(formatedReturnedEmbed, ...(0, utils_1.keysOf)(embed));
    return this.createFailedTest((0, utils_1.diff)(embed, partialReturned));
  }
}

exports.ToEmbedMatch = ToEmbedMatch;
