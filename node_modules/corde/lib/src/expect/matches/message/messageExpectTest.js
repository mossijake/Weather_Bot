"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.MessageExpectTest = void 0;

const discord_js_1 = require("discord.js");

const utils_1 = require("../../../utils");

const expectTest_1 = require("../expectTest");

class MessageExpectTest extends expectTest_1.ExpectTest {
  validateExpect(expect) {
    if (!(0, utils_1.isPrimitiveValue)(expect) && (0, utils_1.typeOf)(expect) !== "object") {
      return this.createReport(
        "expected: expect value to be a primitive value (string, boolean, number) or an IMessageEmbed\n",
        `received: ${(0, utils_1.typeOf)(expect)}`,
      );
    }

    return null;
  }

  createReportForExpectAndResponse(expect, returnedMessage) {
    this.hasPassed = this.isMessagesEquals(returnedMessage, expect);
    this.invertHasPassedIfIsNot();

    if (this.hasPassed) {
      return this.createPassTest();
    }

    let embedReturned;

    if (returnedMessage.embeds[0]) {
      embedReturned = this.getMessageByType(returnedMessage, "embed");
    }

    if ((0, utils_1.typeOf)(expect) === "object" && embedReturned) {
      return this.createReport((0, utils_1.diff)(embedReturned, expect));
    }

    if ((0, utils_1.typeOf)(expect) === "object" && !embedReturned) {
      return this.createReport(
        `expected: ${(0, utils_1.formatObject)(expect)}\n`,
        `received: '${returnedMessage.content}'`,
      );
    }

    if ((0, utils_1.typeOf)(expect) === "string" && embedReturned) {
      return this.createReport(
        `expected: '${expect}'\n`,
        `received: ${(0, utils_1.formatObject)(embedReturned)}`,
      );
    }

    return this.createReport(`expected: '${expect}'\n`, `received: '${returnedMessage.content}'`);
  }

  isMessagesEquals(returnedMessage, expectation) {
    const embed = returnedMessage.embeds[0];

    if ((0, utils_1.isPrimitiveValue)(expectation) && !embed) {
      return expectation == returnedMessage.content;
    }

    if (embed && (0, utils_1.typeOf)(expectation) === "object") {
      const embedInternal = this.messageEmbedToMessageEmbedInterface(embed);
      return (0, utils_1.deepEqual)(expectation, embedInternal);
    }

    return false;
  }

  getMessageByType(answer, type) {
    if (type === "embed") {
      const embed = answer instanceof discord_js_1.Message ? answer.embeds[0] : answer;

      if (!embed) {
        return null;
      }

      return this.messageEmbedToMessageEmbedInterface(embed);
    }

    if (answer instanceof discord_js_1.Message) {
      return answer.content;
    }

    return answer;
  }

  humanizeMessageIdentifierObject(msgIdentifier) {
    if (!msgIdentifier) {
      return "";
    }

    if (msgIdentifier !== null && msgIdentifier !== void 0 && msgIdentifier.id) {
      return `message of id ${msgIdentifier.id}`;
    }

    if (msgIdentifier.content) {
      return `message of content "${msgIdentifier.content}"`;
    }

    if (msgIdentifier.oldContent) {
      return `message of content "${msgIdentifier.oldContent}"`;
    }

    return "";
  }

  messageEmbedToMessageEmbedInterface(message) {
    if (!message) {
      return {};
    }

    const embedLike = {};

    if (message.url) {
      embedLike.url = message.url;
    }

    if (message.timestamp) {
      embedLike.timestamp = message.timestamp;
    }

    if (message.author) {
      if (message.author.iconURL || message.author.url) {
        embedLike.author = {
          iconURL: message.author.iconURL,
          name: message.author.name,
          url: message.author.url,
        };
      } else if (message.author.name) {
        embedLike.author = message.author.name;
      }
    }

    if (message.color) {
      embedLike.color = message.color;
    }

    if (message.description) {
      embedLike.description = message.description;
    }

    if (message.fields && message.fields.length) {
      embedLike.fields = [];
      message.fields.forEach((field) => {
        var _embedLike$fields;

        (_embedLike$fields = embedLike.fields) === null || _embedLike$fields === void 0
          ? void 0
          : _embedLike$fields.push({
              name: field.name,
              value: field.value,
              inline: !!field.inline,
            });
      });
    }

    if (message.files && message.files.length) {
      embedLike.files = [];
      message.files.forEach((file) => {
        if (file instanceof discord_js_1.MessageAttachment) {
          var _embedLike$files;

          (_embedLike$files = embedLike.files) === null || _embedLike$files === void 0
            ? void 0
            : _embedLike$files.push({
                attachment: file.attachment,
                name: file.name,
              });
        } else {
          var _embedLike$files2;

          (_embedLike$files2 = embedLike.files) === null || _embedLike$files2 === void 0
            ? void 0
            : _embedLike$files2.push(file);
        }
      });
    }

    if (message.footer) {
      if (message.footer.iconURL) {
        embedLike.footer = {
          iconURL: message.footer.iconURL,
          text: message.footer.text,
        };
      } else if (message.footer.text) {
        embedLike.footer = message.footer.text;
      }
    }

    if (message.image) {
      if (message.image.height || message.image.width) {
        embedLike.image = {
          url: message.image.url,
          height: message.image.height,
          width: message.image.width,
        };
      } else if (message.image.url) {
        embedLike.image = message.image.url;
      }
    }

    if (message.title) {
      embedLike.title = message.title;
    }

    if (message.thumbnail) {
      embedLike.thumbnailUrl = message.thumbnail.url;
    }

    return embedLike;
  }

  embedMessageInterfaceToMessageEmbed(embedLike) {
    const embed = new discord_js_1.MessageEmbed();

    if (!embedLike || (0, utils_1.typeOf)(embedLike) !== "object") {
      return embed;
    }

    if (embedLike.author) {
      if (typeof embedLike.author === "string") {
        embed.setAuthor(embedLike.author);
      } else {
        embed.setAuthor(embedLike.author.name, embedLike.author.iconURL, embedLike.author.url);
      }
    }

    if (embedLike.color) {
      embed.setColor(embedLike.color);
    }

    if (embedLike.description) {
      embed.setDescription(embedLike.description);
    }

    if (embedLike.fields) {
      embed.addFields(
        ...embedLike.fields.map((field) => {
          return {
            name: field.name,
            value: field.value,
            inline: !!field.inline,
          };
        }),
      );
    }

    if (embedLike.files) {
      embed.attachFiles(
        embedLike.files.map((file) => {
          if (typeof file === "string") {
            return file;
          }

          const attachment = new discord_js_1.MessageAttachment(file.attachment);

          if (file.name) {
            attachment.setName(file.name);
          }

          return attachment;
        }),
      );
    }

    if (embedLike.footer) {
      if (typeof embedLike.footer === "string") {
        embed.setFooter(embedLike.footer);
      } else {
        embed.setFooter(embedLike.footer.text, embedLike.footer.iconURL);
      }
    }

    if (embedLike.image) {
      if (typeof embedLike.image === "string") {
        embed.setImage(embedLike.image);
      } else {
        embed.setImage(embedLike.image.url);
      }
    }

    if (embedLike.thumbnailUrl) {
      embed.setThumbnail(embedLike.thumbnailUrl);
    }

    if (embedLike.timestamp) {
      embed.setTimestamp(embedLike.timestamp);
    }

    if (embedLike.title) {
      embed.setTitle(embedLike.title);
    }

    if (embedLike.url) {
      embed.setURL(embedLike.url);
    }

    return embed;
  }
}

exports.MessageExpectTest = MessageExpectTest;
