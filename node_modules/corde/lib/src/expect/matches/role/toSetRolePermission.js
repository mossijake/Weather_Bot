"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.ToSetRolePermission = void 0;

const types_1 = require("../../../types");

const utils_1 = require("../../../utils");

const roleUtils_1 = require("../../roleUtils");

const expectTest_1 = require("../expectTest");

class ToSetRolePermission extends expectTest_1.ExpectTest {
  constructor(params) {
    super({ ...params, testName: "toSetRolePermission" });
  }

  async action(roleIdentifier, permissions) {
    const identifier = roleUtils_1.roleUtils.getRoleData(roleIdentifier);
    const error = roleUtils_1.roleUtils.getErrorForUndefinedRoleData(identifier);

    if (error) {
      return this.createFailedTest(error);
    }

    if (
      (0, utils_1.typeOf)(permissions) !== "array" &&
      (0, utils_1.typeOf)(permissions) !== "null" &&
      (0, utils_1.typeOf)(permissions) !== "undefined"
    ) {
      return this.createReport(
        "expected: permissions to be null, undefined or an array\n",
        `received: ${(0, utils_1.typeOf)(permissions)}`,
      );
    }

    if (permissions && !isPermissionsValid(permissions)) {
      return this.createReport((0, utils_1.diff)(types_1.permissionsArray, permissions));
    }

    const oldRole = await this.cordeBot.findRole(identifier);
    const invalidRoleErrorMessage = roleUtils_1.roleUtils.validateRole(oldRole, identifier);

    if (invalidRoleErrorMessage) {
      return this.createFailedTest(invalidRoleErrorMessage);
    }

    try {
      await this.sendCommandMessage();
    } catch (error) {
      return this.createFailedTest(error.message);
    }

    let role;

    try {
      role = await this.cordeBot.events.onceRolePermissionUpdate(
        identifier,
        this.timeout,
        this.guildId,
      );
    } catch {
      if (this.isNot) {
        return this.createPassTest();
      }

      return this.createReport(
        `expected: role permissions change to: ${getPermissionsString(permissions)}\n`,
        "received: permissions were not changed",
      );
    }

    if (role.permissions.equals(permissions ?? [])) {
      this.hasPassed = true;
    }

    this.invertHasPassedIfIsNot();

    if (this.hasPassed) {
      return this.createPassTest();
    }

    return this.createReport(
      `expected: role permissions ${this.isNot ? "not " : ""}change to: ${getPermissionsString(
        permissions,
      )}\n`,
      `received: ${getPermissionsString(role.permissions.toArray())}`,
    );
  }
}

exports.ToSetRolePermission = ToSetRolePermission;

function getPermissionsString(permissions) {
  if (!permissions) {
    return null;
  }

  if (permissions.includes("ADMINISTRATOR")) {
    if (permissions.length === 1) {
      return "ADMINISTRATOR";
    }

    if (permissions.length > 2) {
      return `ADMINISTRATOR (and ${
        permissions.filter((p) => p !== "ADMINISTRATOR").length
      } others)`;
    }

    return `ADMINISTRATOR and ${permissions.filter((p) => p !== "ADMINISTRATOR")}`;
  }

  return permissions.join(", ");
}

function isPermissionsValid(permissions) {
  for (let i = 0; i < permissions.length; i++) {
    if (!types_1.permissionsArray.includes(permissions[i])) {
      return false;
    }
  }

  return true;
}
