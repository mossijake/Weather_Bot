"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.reader = exports.Reader = void 0;

const tslib_1 = require("tslib");

const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));

const runtime_1 = require("../common/runtime");

const printHookError_1 = require("../common/printHookError");

const testCollector_1 = require("../common/testCollector");

const errors_1 = require("../errors");

const utils_1 = require("../utils");

class Reader {
  loadConfig() {
    let _config;

    const jsonFilePath = path_1.default.resolve(process.cwd(), "corde.config.json");
    const tsFilePath = path_1.default.resolve(process.cwd(), "corde.config.ts");
    const jsFilePath = path_1.default.resolve(process.cwd(), "corde.config.js");

    if (runtime_1.runtime.configFilePath) {
      return this.loadConfigFromConfigFilePath();
    }

    if (fs_1.default.existsSync(jsonFilePath)) {
      _config = JSON.parse(fs_1.default.readFileSync(jsonFilePath).toString());
    } else if (fs_1.default.existsSync(tsFilePath)) {
      _config = require(tsFilePath);
    } else if (fs_1.default.existsSync(jsFilePath)) {
      _config = require(jsFilePath);
    } else {
      throw new errors_1.FileError("No config file was found");
    }

    if (!_config || Object.keys(_config).length === 0) {
      throw new errors_1.FileError("This appears to be a invalid config file");
    } else {
      return _config;
    }
  }

  async getTestsFromFiles(filesPattern) {
    const testMatches = [];

    if (!filesPattern || !filesPattern.filesPattern.length) {
      throw new errors_1.FileError("No file was informed.");
    }

    const filesPath = [];

    try {
      const matches = await utils_1.utils.getFiles(
        filesPattern.filesPattern,
        filesPattern.ignorePattern,
      );
      filesPath.push(...matches);
    } catch (error) {
      console.log(error);
    }

    for (const file of filesPath) {
      var _runtime_1$runtime$ex;

      const extension = path_1.default.extname(file);

      if (
        (_runtime_1$runtime$ex = runtime_1.runtime.extensions) !== null &&
        _runtime_1$runtime$ex !== void 0 &&
        _runtime_1$runtime$ex.includes(extension)
      ) {
        if (runtime_1.runtime.exitOnFileReadingError) {
          await Promise.resolve().then(() => (0, tslib_1.__importStar)(require(file)));
        } else {
          try {
            await Promise.resolve().then(() => (0, tslib_1.__importStar)(require(file)));
          } catch (error) {
            console.error(error);
            continue;
          }
        }
      }

      const _errors =
        await testCollector_1.testCollector.beforeStartFunctions.executeWithCatchCollectAsync();

      if (_errors && _errors.length) {
        (0, printHookError_1.printHookErrors)(_errors);
      }

      const groupErros = await testCollector_1.testCollector.executeGroupClojure();

      if (groupErros && groupErros.length) {
        (0, printHookError_1.printHookErrors)(groupErros);
      }

      const testErrors = await testCollector_1.testCollector.executeTestClojure();

      if (testErrors && testErrors.length) {
        (0, printHookError_1.printHookErrors)(testErrors);
      }

      this.addTestsGroupmentToGroupIfExist();
      this.addIsolatedTestFunctionsToGroupIfExists();
      const resolvedCwd = process.cwd().replace(/\\/g, "/");
      testMatches.push({
        path: file.replace(resolvedCwd + "/", ""),
        groups: testCollector_1.testCollector.groups.slice(),
        isEmpty: testCollector_1.testCollector.groups.length === 0,
      });
      testCollector_1.testCollector.groups = [];
    }

    return testMatches;
  }

  loadConfigFromConfigFilePath() {
    let filePath = "";

    if (fs_1.default.existsSync(runtime_1.runtime.configFilePath)) {
      filePath = path_1.default.resolve(process.cwd(), runtime_1.runtime.configFilePath);
    } else {
      throw new errors_1.FileError(
        `The path '${runtime_1.runtime.configFilePath}' do not appears to be a valid path`,
      );
    }

    const fileExt = path_1.default.extname(filePath);

    if (fileExt === ".json") {
      return JSON.parse(fs_1.default.readFileSync(filePath).toString());
    } else if (fileExt === ".cjs" || fileExt === ".js" || fileExt === ".ts") {
      return require(filePath);
    } else {
      throw new errors_1.FileError(`Extension '${fileExt}' is not supported`);
    }
  }

  addTestsGroupmentToGroupIfExist() {
    if (testCollector_1.testCollector.tests && testCollector_1.testCollector.tests.length > 0) {
      const testsCloned = testCollector_1.testCollector.tests.slice();
      testCollector_1.testCollector.groups.push({
        tests: testsCloned,
      });
      testCollector_1.testCollector.tests = [];
    }
  }

  addIsolatedTestFunctionsToGroupIfExists() {
    if (testCollector_1.testCollector.hasIsolatedTestFunctions()) {
      const testsCloned = testCollector_1.testCollector.cloneIsolatedTestFunctions();
      testCollector_1.testCollector.groups.push({
        tests: [
          {
            testsFunctions: testsCloned,
          },
        ],
      });
      testCollector_1.testCollector.clearIsolatedTestFunctions();
    }
  }
}

exports.Reader = Reader;
const reader = new Reader();
exports.reader = reader;
