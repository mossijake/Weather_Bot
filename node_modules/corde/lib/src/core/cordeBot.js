"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.CordeBot = void 0;

const tslib_1 = require("tslib");

const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));

const discord_js_1 = require("discord.js");

const errors_1 = require("../errors");

const utils_1 = require("../utils");

const events_1 = require("./events");

class CordeBot {
  constructor(prefix, guildId, channelId, testBotId, client) {
    this.events = new events_1.Events(client);
    this._client = client;
    this._channelId = channelId;
    this._prefix = prefix;
    this._guildId = guildId;
    this._testBotId = testBotId;
    this.loadClientEvents();
    this._isReady = false;
  }

  get client() {
    return this._client;
  }

  get guild() {
    return this.textChannel.guild;
  }

  get roleManager() {
    return this.guild.roles;
  }

  get channel() {
    return this.textChannel;
  }

  get testBotId() {
    return this._testBotId;
  }

  get voiceConnection() {
    return this._voiceConnection;
  }

  get id() {
    var _this$_client$user;

    return (_this$_client$user = this._client.user) === null || _this$_client$user === void 0
      ? void 0
      : _this$_client$user.id;
  }

  async login(token) {
    try {
      return this._client.login(token);
    } catch (error) {
      throw new errors_1.CordeClientError(this.buildLoginErrorMessage(token, error.message));
    }
  }

  fetchChannel(id) {
    return this._client.channels.fetch(id, true);
  }

  fetchGuild(id) {
    return this._client.guilds.fetch(id, true);
  }

  logout() {
    this._client.destroy();
  }

  async sendMessage(message) {
    return await this.textChannel.send(message);
  }

  async sendTextMessage(message, channelId) {
    this.validateMessageAndChannel(message);
    const formattedMessage = this._prefix + message;

    if (channelId) {
      const channel = await this.findChannelById(channelId);

      if (!channel) {
        throw new Error(`Channel ${channelId} was not found`);
      }

      if (channel.isText()) {
        const returnedMessage = await channel.send(formattedMessage);
        return returnedMessage;
      }

      throw new Error("Can not send a message to a non text channel");
    }

    const returnedMessage = await this.textChannel.send(formattedMessage);
    return returnedMessage;
  }

  async findChannelById(channelId) {
    const channel = this._client.channels.cache.get(channelId);

    if (channel) {
      return channel;
    }

    return await this._client.channels.fetch(channelId, true);
  }

  isLoggedIn() {
    return !!this._client && !!this._client.readyAt && this._isReady;
  }

  async findMessage(data) {
    const messageIdentifier = data;

    if (messageIdentifier && messageIdentifier.content) {
      return this._findMessage((m) => m.content === messageIdentifier.content);
    }

    if (messageIdentifier && messageIdentifier.id) {
      return this._findMessage((m) => m.id === messageIdentifier.id);
    }

    if (data) {
      return this._findMessage(data);
    }

    return undefined;
  }

  async fetchRole(id) {
    return await this.guild.roles.fetch(id, false, true);
  }

  async fetchRoles() {
    return await this.guild.roles.fetch();
  }

  async hasRole(roleIdentifier) {
    return !!(await this.findRole(roleIdentifier));
  }

  async findRole(roleIdentifier) {
    const data = await this.guild.roles.fetch();

    if (roleIdentifier.id) {
      return data.cache.find((r) => r.id === roleIdentifier.id);
    } else if (roleIdentifier.name) {
      return data.cache.find((r) => r.name === roleIdentifier.name);
    }

    return undefined;
  }

  getRoles() {
    return this.guild.roles.cache;
  }

  async _findMessage(fn) {
    const collection = await this.textChannel.messages.fetch();

    if (collection) {
      return collection.find(fn);
    }

    return undefined;
  }

  loadChannel() {
    const guild = this.findGuild(this._guildId);
    const channel = this.findChannel(guild, this._channelId);

    if (!channel) {
      throw new errors_1.CordeClientError("Could not load channel " + this._channelId);
    }

    this.textChannel = this.convertToTextChannel(channel);
  }

  loadClientEvents() {
    this.events.onReady(() => {
      this._isReady = true;
      this.loadChannel();
    });
  }

  buildLoginErrorMessage(token, error) {
    if (!token) {
      return `Error trying to login with ${chalk_1.default.bold((0, utils_1.typeOf)(token))} token`;
    }

    return `Error trying to login with token ${chalk_1.default.bold(token)}. \n` + error;
  }

  validateMessageAndChannel(message) {
    if (!message) {
      throw new errors_1.CordeClientError("No tests were declared");
    }

    if (!this.textChannel) {
      throw new errors_1.CordeClientError("Channel not found");
    }
  }

  findGuild(guildId) {
    if (!this._client.guilds) {
      throw new errors_1.CordeClientError(
        `corde bot isn't added in a guild. Please add it to the guild: ${guildId}`,
      );
    } else if (!this._client.guilds.cache.has(guildId)) {
      throw new errors_1.CordeClientError(
        `Guild ${guildId} doesn't belong to corde bot. change the guild id ` +
          " in corde.config or add the bot to a valid guild",
      );
    } else {
      const guild = this._client.guilds.cache.find((_guild) => _guild.id === guildId);

      if (guild) {
        return guild;
      }

      const availableGuildsIds = this._client.guilds.cache.map(
        (guildAvailable) => guildAvailable.id,
      );

      throw new errors_1.CordeClientError(
        `Could not find the guild ${guildId}.` +
          ` this client has connections with the following guilds: ${availableGuildsIds}`,
      );
    }
  }

  findChannel(channelIdOrGuild, channelId) {
    if (typeof channelIdOrGuild === "string") {
      return this.guild.channels.cache.get(channelIdOrGuild);
    }

    const guild = channelIdOrGuild;

    if (!channelId) {
      throw new errors_1.CordeClientError("no channel id provided");
    }

    if (!guild.channels) {
      throw new errors_1.CordeClientError(`Guild '${guild.name}' do not have any channel.`);
    } else if (!guild.channels.cache.has(channelId)) {
      throw new errors_1.CordeClientError(
        `channel ${channelId} doesn't appear to be a channel of guild ${guild.name}`,
      );
    } else {
      const channel = guild.channels.cache.find((ch) => ch.id === channelId);

      if (channel === undefined) {
        throw new errors_1.CordeClientError("There is no informed channel to start tests");
      }

      return channel;
    }
  }

  async joinVoiceChannel(channelId) {
    const channel = this._client.channels.cache.get(channelId);

    if (!channel) {
      throw new errors_1.CordeClientError(`channel ${channelId} not found`);
    }

    if (channel.isText()) {
      throw new errors_1.CordeClientError("can not join a text channel");
    }

    if (channel instanceof discord_js_1.VoiceChannel) {
      this._voiceConnection = {
        channel: channel,
        connection: await channel.join(),
      };
      return this._voiceConnection;
    }

    throw new errors_1.CordeClientError("channel is not a voice channel to connect");
  }

  isInVoiceChannel() {
    return !!this._voiceConnection;
  }

  isStreamingInVoiceChannel() {
    var _this$_voiceConnectio;

    return !!(
      (_this$_voiceConnectio = this._voiceConnection) !== null &&
      _this$_voiceConnectio !== void 0 &&
      _this$_voiceConnectio.connection
    );
  }

  stopStream() {
    var _this$_voiceConnectio2, _this$_voiceConnectio3;

    (_this$_voiceConnectio2 = this._voiceConnection) === null || _this$_voiceConnectio2 === void 0
      ? void 0
      : (_this$_voiceConnectio3 = _this$_voiceConnectio2.connection) === null ||
        _this$_voiceConnectio3 === void 0
      ? void 0
      : _this$_voiceConnectio3.disconnect();
  }

  leaveVoiceChannel() {
    var _this$_voiceConnectio4;

    (_this$_voiceConnectio4 = this._voiceConnection) === null || _this$_voiceConnectio4 === void 0
      ? void 0
      : _this$_voiceConnectio4.channel.leave();
    this._voiceConnection = undefined;
  }

  convertToTextChannel(channel) {
    return channel;
  }
}

exports.CordeBot = CordeBot;
